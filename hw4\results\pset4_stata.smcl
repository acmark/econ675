{smcl}
{com}{sf}{ul off}{txt}{.-}
      name:  {res}<unnamed>
       {txt}log:  {res}/Users/erinmarkiewitz/Dropbox/Phd_Coursework/Econ675/hw4\results\pset4_stata.smcl
  {txt}log type:  {res}smcl
 {txt}opened on:  {res} 9 Nov 2018, 16:16:46
{txt}
{com}. 
. 
. ****
. * Question 2
. ****
. /*
> clear all
> set seed 12345
> scalar n1 = 185
> scalar n0 = 260
> scalar n2 = 2490
> import delimited using LaLonde_all.csv, clear 
> gen log_re74 = log(re74 + 1)
> gen log_re75 = log(re75 + 1)
> gen age2 = age^2
> gen age3 = age^3
> gen educ2 = educ^2
> gen black_u74 = black*u74
> gen educ_log_re74 = educ*log_re74
> 
> local covars_a = "age educ black hisp  married nodegr log_re74 log_re75"
> local covars_b = "age educ black hisp  married nodegr log_re74 log_re75 age2 educ2 u74 u75"
> local covars_c = "age educ black hisp  married nodegr log_re74 log_re75 age2 educ2 u74 u75 age3 black_u74 educ_log_re74"
> 
> 
> *initialize matricies (0) Experimental data, (2) PSID Control
> 
> mat ate0 = J(19,4,.) 
> mat att0 = J(19,4,.) 
> mat ate2 = J(19,4,.) 
> mat att2 = J(19,4,.) 
> 
> *diff in means 
> reg re78 treat if treat ==1 | treat == 0, hc2
> mat ate0[1,1] = _b[treat]
> mat ate0[1,2] = _se[treat]
> mat ate0[1,3] = ate0[1,1] - _se[treat] * 1.96
> mat ate0[1,4] = ate0[1,1] + _se[treat] * 1.96
> 
> mat att0[1,1] = _b[treat]
> mat att0[1,2] = _se[treat]
> mat att0[1,3] = att0[1,1] - _se[treat] * 1.96
> mat att0[1,4] = att0[1,1] + _se[treat] * 1.96
> 
> reg re78 treat if treat ==1 | treat == 2, hc2
> 
> mat ate2[1,1] = - _b[treat]
> mat ate2[1,2] = _se[treat]
> mat ate2[1,3] = ate2[1,1] - _se[treat] * 1.96
> mat ate2[1,4] = ate2[1,1] + _se[treat] * 1.96
> 
> mat att2[1,1] = - _b[treat]
> mat att2[1,2] = _se[treat]
> mat att2[1,3] = att2[1,1] - _se[treat] * 1.96
> mat att2[1,4] = att2[1,1] + _se[treat] * 1.96
> 
> 
> 
> 
> *OLS
> local base_count = 2
> foreach num of numlist 0 2 {c -(} 
> local count = `base_count'
> 
> foreach cv in a b c {c -(} 
> di "`covars_`cv''"
> di "`num'"
> reg re78 treat `covars_`cv'' if treat ==1 | treat == `num', hc2
> mat ate`num'[`count',1] = _b[treat] * (1 - `num') // stata thinks 2 is treatment
> mat ate`num'[`count',2] = _se[treat]
> mat ate`num'[`count',3] = ate`num'[`count',1] - _se[treat] * 1.96
> mat ate`num'[`count',4] = ate`num'[`count',1] + _se[treat] * 1.96
> 
> mat att`num'[`count',1] = _b[treat] * (1 - `num') // stata thinks 2 is treatment
> mat att`num'[`count',2] = _se[treat]
> mat att`num'[`count',3] = att`num'[`count',1] - _se[treat] * 1.96
> mat att`num'[`count',4] = att`num'[`count',1] + _se[treat] * 1.96
> 
> local ++count 
> {c )-}
> {c )-}
> 
> 
> *Reg. Impute
> local base_count = `count' 
> foreach num of numlist 0 2 {c -(} 
> local count = `base_count'
> 
> foreach cv in a b c {c -(} 
> di "`covars_`cv''"
> di "`num'"
> teffects ra (re78 `covars_`cv'') (treat) if treat ==1 | treat == `num', ate
> local colnmsb: coln e(b)
> local colnmsv: coln e(V)
> local colb: word 1 of `colnmsb'
> local colv: word 1 of `colnmsv'
> mat ate`num'[`count',1] = _b[`colb'] * (1 - `num') // stata thinks 2 is treatment
> mat ate`num'[`count',2] = _se[`colv']
> mat ate`num'[`count',3] = ate`num'[`count',1] - ate`num'[`count',2] * 1.96
> mat ate`num'[`count',4] = ate`num'[`count',1] + ate`num'[`count',2] * 1.96
> 
> teffects ra (re78 `covars_`cv'') (treat) if treat ==1 | treat == `num', atet
> local colnmsb: coln e(b)
> local colnmsv: coln e(V)
> local colb: word 1 of `colnmsb'
> local colv: word 1 of `colnmsv'
> mat att`num'[`count',1] = _b[`colb'] * (1 - `num') // stata thinks 2 is treatment
> mat att`num'[`count',2] = _se[`colv']
> mat att`num'[`count',3] = att`num'[`count',1] - att`num'[`count',2] * 1.96
> mat att`num'[`count',4] = att`num'[`count',1] + att`num'[`count',2] * 1.96
> 
> local ++count 
> {c )-}
> {c )-}
> 
> 
> *IPW 
> local base_count = `count' 
> foreach num of numlist 0 2 {c -(} 
> local count = `base_count'
> 
> foreach cv in a b c {c -(} 
> di "`covars_`cv''"
> di "`num'"
> capture teffects ipw (re78) (treat `covars_`cv'', logit) if treat ==1 | treat == `num', ate osample(otest) iter(500)
>  if _rc==498 {c -(}
>                display "Overlap Assumption Violated"
>                            teffects ipw (re78) (treat `covars_`cv'', logit) if (treat ==1 | treat == `num') & otest ==0, ate iter(500)
> {c )-}
> drop otest
> local colnmsb: coln e(b)
> local colnmsv: coln e(V)
> local colb: word 1 of `colnmsb'
> local colv: word 1 of `colnmsv'
> mat ate`num'[`count',1] = _b[`colb'] * (1 - `num') // stata thinks 2 is treatment
> mat ate`num'[`count',2] = _se[`colv']
> mat ate`num'[`count',3] = ate`num'[`count',1] - ate`num'[`count',2] * 1.96
> mat ate`num'[`count',4] = ate`num'[`count',1] + ate`num'[`count',2] * 1.96
> 
> capture teffects ipw (re78) (treat `covars_`cv'', logit) if treat ==1 | treat == `num', atet osample(otest) iter(500)
>  if _rc==498 {c -(}
>                display "Overlap Assumption Violated"
>                             teffects ipw (re78) (treat `covars_`cv'', logit) if (treat ==1 | treat == `num') & otest ==0, atet iter(500)
> {c )-}
> drop otest
> local colnmsb: coln e(b)
> local colnmsv: coln e(V)
> local colb: word 1 of `colnmsb'
> local colv: word 1 of `colnmsv'
> mat att`num'[`count',1] = _b[`colb'] * (1 - `num') // stata thinks 2 is treatment
> mat att`num'[`count',2] = _se[`colv']
> mat att`num'[`count',3] = att`num'[`count',1] - att`num'[`count',2] * 1.96
> mat att`num'[`count',4] = att`num'[`count',1] + att`num'[`count',2] * 1.96
> 
> 
> local ++count 
> {c )-}
> {c )-}
> 
> 
> *DR 
> local base_count = `count' 
> foreach num of numlist 0 2 {c -(} 
> local count = `base_count'
> 
> foreach cv in a b c {c -(} 
> di "`covars_`cv''"
> di "`num'"
> capture teffects ipwra (re78) (treat `covars_`cv'', logit) if treat ==1 | treat == `num', ate osample(otest) iter(500)
>  if _rc==498 {c -(}
>                display "Overlap Assumption Violated"
>                            teffects ipw (re78) (treat `covars_`cv'', logit) if (treat ==1 | treat == `num') & otest ==0, ate iter(500)
> {c )-}
> drop otest
> local colnmsb: coln e(b)
> local colnmsv: coln e(V)
> local colb: word 1 of `colnmsb'
> local colv: word 1 of `colnmsv'
> mat ate`num'[`count',1] = _b[`colb'] * (1 - `num') // stata thinks 2 is treatment
> mat ate`num'[`count',2] = _se[`colv']
> mat ate`num'[`count',3] = ate`num'[`count',1] - ate`num'[`count',2] * 1.96
> mat ate`num'[`count',4] = ate`num'[`count',1] + ate`num'[`count',2] * 1.96
> 
> capture teffects ipwra (re78) (treat `covars_`cv'', logit) if treat ==1 | treat == `num', atet osample(otest) iter(500)
>  if _rc==498 {c -(}
>                display "Overlap Assumption Violated"
>                             teffects ipw (re78) (treat `covars_`cv'', logit) if (treat ==1 | treat == `num') & otest ==0, atet iter(500)
> {c )-}
> drop otest
> local colnmsb: coln e(b)
> local colnmsv: coln e(V)
> local colb: word 1 of `colnmsb'
> local colv: word 1 of `colnmsv'
> mat att`num'[`count',1] = _b[`colb'] * (1 - `num') // stata thinks 2 is treatment
> mat att`num'[`count',2] = _se[`colv']
> mat att`num'[`count',3] = att`num'[`count',1] - att`num'[`count',2] * 1.96
> mat att`num'[`count',4] = att`num'[`count',1] + att`num'[`count',2] * 1.96
> 
> 
> local ++count 
> {c )-}
> {c )-}
> 
> 
> *Reg. Impute
> local base_count = `count' 
> foreach num of numlist 0 2 {c -(} 
> local count = `base_count'
> 
> foreach cv in a b c {c -(} 
> di "`covars_`cv''"
> di "`num'"
> teffects nnmatch (re78 `covars_`cv'') (treat) if treat ==1 | treat == `num', ate nneighbor(1) metric(maha)
> local colnmsb: coln e(b)
> local colnmsv: coln e(V)
> local colb: word 1 of `colnmsb'
> local colv: word 1 of `colnmsv'
> mat ate`num'[`count',1] = _b[`colb'] * (1 - `num') // stata thinks 2 is treatment
> mat ate`num'[`count',2] = _se[`colv']
> mat ate`num'[`count',3] = ate`num'[`count',1] - ate`num'[`count',2] * 1.96
> mat ate`num'[`count',4] = ate`num'[`count',1] + ate`num'[`count',2] * 1.96
> 
> teffects nnmatch (re78 `covars_`cv'') (treat) if treat ==1 | treat == `num', atet nneighbor(1) metric(maha)
> local colnmsb: coln e(b)
> local colnmsv: coln e(V)
> local colb: word 1 of `colnmsb'
> local colv: word 1 of `colnmsv'
> mat att`num'[`count',1] = _b[`colb'] * (1 - `num') // stata thinks 2 is treatment
> mat att`num'[`count',2] = _se[`colv']
> mat att`num'[`count',3] = att`num'[`count',1] - att`num'[`count',2] * 1.96
> mat att`num'[`count',4] = att`num'[`count',1] + att`num'[`count',2] * 1.96
> 
> local ++count 
> {c )-}
> {c )-}
> 
> *PS Matching 
> local base_count = `count' 
> foreach num of numlist 0 2 {c -(} 
> local count = `base_count'
> 
> foreach cv in a b c {c -(} 
> di "`covars_`cv''"
> di "`num'"
> capture teffects psmatch (re78) (treat `covars_`cv'', logit) if treat ==1 | treat == `num', ate osample(otest) iter(500)
>  if _rc==498 {c -(}
>                display "Overlap Assumption Violated"
>                            teffects psmatch (re78) (treat `covars_`cv'', logit) if (treat ==1 | treat == `num') & otest ==0, ate iter(500)
> {c )-}
> cap drop otest
> local colnmsb: coln e(b)
> local colnmsv: coln e(V)
> local colb: word 1 of `colnmsb'
> local colv: word 1 of `colnmsv'
> mat ate`num'[`count',1] = _b[`colb'] * (1 - `num') // stata thinks 2 is treatment
> mat ate`num'[`count',2] = _se[`colv']
> mat ate`num'[`count',3] = ate`num'[`count',1] - ate`num'[`count',2] * 1.96
> mat ate`num'[`count',4] = ate`num'[`count',1] + ate`num'[`count',2] * 1.96
> 
> capture teffects psmatch (re78) (treat `covars_`cv'', logit) if treat ==1 | treat == `num', atet osample(otest) iter(500)
>  if _rc==498 {c -(}
>                display "Overlap Assumption Violated"
>                             teffects psmatch (re78) (treat `covars_`cv'', logit) if (treat ==1 | treat == `num') & otest ==0, atet iter(500)
> {c )-}
> cap drop otest
> local colnmsb: coln e(b)
> local colnmsv: coln e(V)
> local colb: word 1 of `colnmsb'
> local colv: word 1 of `colnmsv'
> mat att`num'[`count',1] = _b[`colb'] * (1 - `num') // stata thinks 2 is treatment
> mat att`num'[`count',2] = _se[`colv']
> mat att`num'[`count',3] = att`num'[`count',1] - att`num'[`count',2] * 1.96
> mat att`num'[`count',4] = att`num'[`count',1] + att`num'[`count',2] * 1.96
> 
> 
> local ++count 
> {c )-}
> {c )-}
> 
> 
> 
> mat li ate0
> mat li ate2
> 
> mat li att0
> mat li att2
> **TODO: put into charts 
> 
> */
. 
. 
. ****
. * Question 3
. ****
. 
. clear all
{res}{txt}
{com}. set seed 12345 
{txt}
{com}. 
. *construct dgp variance covariance matrix 
. matrix P = (1,.85 \.85, 1)
{txt}
{com}. mat A = cholesky(P)
{txt}
{com}. 
. program modelsim, rclass
{txt}  1{com}.         args A
{txt}  2{com}.         drop _all 
{txt}  3{com}.         set obs 50
{txt}  4{com}. 
.         *generate component normal variables 
.         gen c1= invnorm(uniform())
{txt}  5{com}.         gen c2= invnorm(uniform())
{txt}  6{com}. 
.         *use cholesky decomp to back out x,z 
.         gen x = `A'[1,1] * c1 + `A'[1,2] * c2
{txt}  7{com}.         gen z = `A'[2,1] * c1 + `A'[2,2] * c2
{txt}  8{com}. 
.         *general epsilon and outcome variable 
.         gen e= invnorm(uniform())
{txt}  9{com}.         gen y = 0.5*x + z + e 
{txt} 10{com}. 
. 
.         *simulate model selection process (flip order of regs for speed) 
.         reg y x 
{txt} 11{com}.         scalar beta_tilde = _b[x]
{txt} 12{com}.         
.         reg y x z 
{txt} 13{com}.         scalar beta_hat = _b[x]
{txt} 14{com}. 
. 
.         if abs(_b[z]/_se[z])>=1.96 {c -(}
{txt} 15{com}.                 scalar beta_check = beta_hat
{txt} 16{com}.         {c )-}
{txt} 17{com}.         else{c -(}
{txt} 18{com}.                 scalar beta_check = beta_tilde
{txt} 19{com}.         {c )-}
{txt} 20{com}.         
. end
{txt}
{com}. 
. simulate beta_hat = beta_hat beta_check=beta_check beta_tilde=beta_tilde, ///
> seed(1234) reps(1000): modelsim A
{p2colset 7 17 21 2}{...}

{txt}{p2col :command:}modelsim A{p_end}
{p2colset 6 17 21 2}{...}
{p2col :beta_hat:}{res:beta_hat}{p_end}
{p2colset 4 17 21 2}{...}
{p2col :beta_check:}{res:beta_check}{p_end}
{p2colset 4 17 21 2}{...}
{p2col :beta_tilde:}{res:beta_tilde}{p_end}

Simulations ({res}1000{txt})
{hline 4}{c +}{hline 3} 1 {hline 3}{c +}{hline 3} 2 {hline 3}{c +}{hline 3} 3 {hline 3}{c +}{hline 3} 4 {hline 3}{c +}{hline 3} 5 
..................................................    50
..................................................   100
..................................................   150
..................................................   200
..................................................   250
..................................................   300
..................................................   350
..................................................   400
..................................................   450
..................................................   500
..................................................   550
..................................................   600
..................................................   650
..................................................   700
..................................................   750
..................................................   800
..................................................   850
..................................................   900
..................................................   950
..................................................  1000

{com}. 
. **TODO: empircal coverage rate 
. 
. **
. 
. sum * 

{txt}    Variable {c |}        Obs        Mean    Std. Dev.       Min        Max
{hline 13}{c +}{hline 57}
{space 4}beta_hat {c |}{res}      1,000    .5153213    .2900555  -.3544536   1.436695
{txt}{space 2}beta_check {c |}{res}      1,000    .5415224    .3413071  -.3544536   1.705497
{txt}{space 2}beta_tilde {c |}{res}      1,000    1.358649    .1663243   .8311836   1.950815
{txt}
{com}. estpost summarize *

{txt}{space 0}{space 0}{ralign 12:}{space 1}{c |}{space 1}{ralign 9:e(count)}{space 1}{space 1}{ralign 9:e(sum_w)}{space 1}{space 1}{ralign 9:e(mean)}{space 1}{space 1}{ralign 9:e(Var)}{space 1}{space 1}{ralign 9:e(sd)}{space 1}{space 1}{ralign 9:e(min)}{space 1}{space 1}{ralign 9:e(max)}{space 1}{space 1}{ralign 9:e(sum)}{space 1}
{space 0}{hline 13}{c   +}{hline 11}{hline 11}{hline 11}{hline 11}{hline 11}{hline 11}{hline 11}{hline 11}
{space 0}{space 0}{ralign 12:beta_hat}{space 1}{c |}{space 1}{ralign 9:{res:{sf:     1000}}}{space 1}{space 1}{ralign 9:{res:{sf:     1000}}}{space 1}{space 1}{ralign 9:{res:{sf: .5153213}}}{space 1}{space 1}{ralign 9:{res:{sf: .0841322}}}{space 1}{space 1}{ralign 9:{res:{sf: .2900555}}}{space 1}{space 1}{ralign 9:{res:{sf:-.3544536}}}{space 1}{space 1}{ralign 9:{res:{sf: 1.436695}}}{space 1}{space 1}{ralign 9:{res:{sf: 515.3213}}}{space 1}
{space 0}{space 0}{ralign 12:beta_check}{space 1}{c |}{space 1}{ralign 9:{res:{sf:     1000}}}{space 1}{space 1}{ralign 9:{res:{sf:     1000}}}{space 1}{space 1}{ralign 9:{res:{sf: .5415224}}}{space 1}{space 1}{ralign 9:{res:{sf: .1164905}}}{space 1}{space 1}{ralign 9:{res:{sf: .3413071}}}{space 1}{space 1}{ralign 9:{res:{sf:-.3544536}}}{space 1}{space 1}{ralign 9:{res:{sf: 1.705497}}}{space 1}{space 1}{ralign 9:{res:{sf: 541.5224}}}{space 1}
{space 0}{space 0}{ralign 12:beta_tilde}{space 1}{c |}{space 1}{ralign 9:{res:{sf:     1000}}}{space 1}{space 1}{ralign 9:{res:{sf:     1000}}}{space 1}{space 1}{ralign 9:{res:{sf: 1.358649}}}{space 1}{space 1}{ralign 9:{res:{sf: .0276638}}}{space 1}{space 1}{ralign 9:{res:{sf: .1663243}}}{space 1}{space 1}{ralign 9:{res:{sf: .8311836}}}{space 1}{space 1}{ralign 9:{res:{sf: 1.950815}}}{space 1}{space 1}{ralign 9:{res:{sf: 1358.649}}}{space 1}

{com}. estout using hw4_q3_1_stata.tex, cells("mean sd min max") style(tex)  replace
{res}{txt}(note: file hw4_q3_1_stata.tex not found)
(output written to {browse  `"hw4_q3_1_stata.tex"'})

{com}. 
. kdensity beta_hat, normal name(beta_hat,replace)
{res}{txt}
{com}. gr export hw4_q3_bhat_stata.png ,replace
{txt}(file hw4_q3_bhat_stata.png written in PNG format)

{com}. kdensity beta_check, normal name(beta_check,replace)
{res}{txt}
{com}. gr export hw4_q3_bcheck_stata.png ,replace
{txt}(file hw4_q3_bcheck_stata.png written in PNG format)

{com}. kdensity beta_tilde,normal name(beta_tilde,replace)
{res}{txt}
{com}. gr export hw4_q3_btilde_stata.png ,replace
{txt}(file hw4_q3_btilde_stata.png written in PNG format)

{com}. 
. sum beta_hat

{txt}    Variable {c |}        Obs        Mean    Std. Dev.       Min        Max
{hline 13}{c +}{hline 57}
{space 4}beta_hat {c |}{res}      1,000    .5153213    .2900555  -.3544536   1.436695
{txt}
{com}. gen cov_uppers_hat = beta_hat + 1.96*r(sd)/sqrt(50)
{txt}
{com}. gen cov_lowers_hat = beta_hat - 1.96*r(sd)/sqrt(50)
{txt}
{com}. gen covrate_hat =  cond(0.5<= cov_uppers_hat & 0.5>= cov_lowers_hat,1,0)
{txt}
{com}. 
. sum beta_tilde

{txt}    Variable {c |}        Obs        Mean    Std. Dev.       Min        Max
{hline 13}{c +}{hline 57}
{space 2}beta_tilde {c |}{res}      1,000    1.358649    .1663243   .8311836   1.950815
{txt}
{com}. gen cov_uppers_tilde = beta_tilde + 1.96*r(sd)/sqrt(50)
{txt}
{com}. gen cov_lowers_tilde = beta_tilde - 1.96*r(sd)/sqrt(50)
{txt}
{com}. gen covrate_tilde =  cond(0.5<= cov_uppers_tilde & 0.5>= cov_lowers_tilde,1,0)
{txt}
{com}. 
. sum beta_check

{txt}    Variable {c |}        Obs        Mean    Std. Dev.       Min        Max
{hline 13}{c +}{hline 57}
{space 2}beta_check {c |}{res}      1,000    .5415224    .3413071  -.3544536   1.705497
{txt}
{com}. gen cov_uppers_check = beta_check + 1.96*r(sd)/sqrt(50)
{txt}
{com}. gen cov_lowers_check = beta_check - 1.96*r(sd)/sqrt(50)
{txt}
{com}. gen covrate_check =  cond(0.5<= cov_uppers_check & 0.5>= cov_lowers_check,1,0)
{txt}
{com}. 
. sum covrate*

{txt}    Variable {c |}        Obs        Mean    Std. Dev.       Min        Max
{hline 13}{c +}{hline 57}
{space 1}covrate_hat {c |}{res}      1,000        .201    .4009486          0          1
{txt}covrate_ti~e {c |}{res}      1,000           0           0          0          0
{txt}covrate_ch~k {c |}{res}      1,000        .244    .4297076          0          1
{txt}
{com}. estout using hw4_q3_2_stata.tex, cells("mean ") style(tex)  replace
{res}{txt}(note: file hw4_q3_2_stata.tex not found)
(output written to {browse  `"hw4_q3_2_stata.tex"'})

{com}. 
. 
. 
. 
. 
. 
. 
. 
. 
. 
. cap log close
{smcl}
{com}{sf}{ul off}